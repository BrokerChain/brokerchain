// auto generated by dev/system

import { Logger } from "../../../myutils/logger.js";

export interface Input {
    algorithm:
        | "aes-128-cbc"
        | "aes-128-cbc-hmac-sha1"
        | "aes-128-cbc-hmac-sha256"
        | "aes-128-ccm"
        | "aes-128-cfb"
        | "aes-128-cfb1"
        | "aes-128-cfb8"
        | "aes-128-ctr"
        | "aes-128-ecb"
        | "aes-128-gcm"
        | "aes-128-ocb"
        | "aes-128-ofb"
        | "aes-128-xts"
        | "aes-192-cbc"
        | "aes-192-ccm"
        | "aes-192-cfb"
        | "aes-192-cfb1"
        | "aes-192-cfb8"
        | "aes-192-ctr"
        | "aes-192-ecb"
        | "aes-192-gcm"
        | "aes-192-ocb"
        | "aes-192-ofb"
        | "aes-256-cbc"
        | "aes-256-cbc-hmac-sha1"
        | "aes-256-cbc-hmac-sha256"
        | "aes-256-ccm"
        | "aes-256-cfb"
        | "aes-256-cfb1"
        | "aes-256-cfb8"
        | "aes-256-ctr"
        | "aes-256-ecb"
        | "aes-256-gcm"
        | "aes-256-ocb"
        | "aes-256-ofb"
        | "aes-256-xts"
        | "aes128"
        | "aes128-wrap"
        | "aes192"
        | "aes192-wrap"
        | "aes256"
        | "aes256-wrap"
        | "aria-128-cbc"
        | "aria-128-ccm"
        | "aria-128-cfb"
        | "aria-128-cfb1"
        | "aria-128-cfb8"
        | "aria-128-ctr"
        | "aria-128-ecb"
        | "aria-128-gcm"
        | "aria-128-ofb"
        | "aria-192-cbc"
        | "aria-192-ccm"
        | "aria-192-cfb"
        | "aria-192-cfb1"
        | "aria-192-cfb8"
        | "aria-192-ctr"
        | "aria-192-ecb"
        | "aria-192-gcm"
        | "aria-192-ofb"
        | "aria-256-cbc"
        | "aria-256-ccm"
        | "aria-256-cfb"
        | "aria-256-cfb1"
        | "aria-256-cfb8"
        | "aria-256-ctr"
        | "aria-256-ecb"
        | "aria-256-gcm"
        | "aria-256-ofb"
        | "aria128"
        | "aria192"
        | "aria256"
        | "camellia-128-cbc"
        | "camellia-128-cfb"
        | "camellia-128-cfb1"
        | "camellia-128-cfb8"
        | "camellia-128-ctr"
        | "camellia-128-ecb"
        | "camellia-128-ofb"
        | "camellia-192-cbc"
        | "camellia-192-cfb"
        | "camellia-192-cfb1"
        | "camellia-192-cfb8"
        | "camellia-192-ctr"
        | "camellia-192-ecb"
        | "camellia-192-ofb"
        | "camellia-256-cbc"
        | "camellia-256-cfb"
        | "camellia-256-cfb1"
        | "camellia-256-cfb8"
        | "camellia-256-ctr"
        | "camellia-256-ecb"
        | "camellia-256-ofb"
        | "camellia128"
        | "camellia192"
        | "camellia256"
        | "chacha20"
        | "chacha20-poly1305"
        | "des-ede"
        | "des-ede-cbc"
        | "des-ede-cfb"
        | "des-ede-ecb"
        | "des-ede-ofb"
        | "des-ede3"
        | "des-ede3-cbc"
        | "des-ede3-cfb"
        | "des-ede3-cfb1"
        | "des-ede3-cfb8"
        | "des-ede3-ecb"
        | "des-ede3-ofb"
        | "des3"
        | "des3-wrap"
        | "id-aes128-CCM"
        | "id-aes128-GCM"
        | "id-aes128-wrap"
        | "id-aes128-wrap-pad"
        | "id-aes192-CCM"
        | "id-aes192-GCM"
        | "id-aes192-wrap"
        | "id-aes192-wrap-pad"
        | "id-aes256-CCM"
        | "id-aes256-GCM"
        | "id-aes256-wrap"
        | "id-aes256-wrap-pad"
        | "id-smime-alg-CMS3DESwrap"
        | "sm4"
        | "sm4-cbc"
        | "sm4-cfb"
        | "sm4-ctr"
        | "sm4-ecb"
        | "sm4-ofb";
    key_hex: string;
    iv_hex: string;
    plain_text: string;
}

export interface OutputOk {
    ciphered_text_hex: string;
}

export interface OutputFail {}

export interface Callback<R> {
    ok: (output: OutputOk) => R;
    fail: (err: Error) => R;
}

export function check_input<R>(plog: Logger, v: any, cb: { ok: () => R; fail: (err: Error) => R }): R {
    const log = plog.sub("check_input");
    log.variable("v", v);
    try {
        log.println("v must be object");
        if (typeof v !== "object" || v === null) {
            throw new Error("v is not object");
        }

        Object.keys(v).forEach((field) => {
            if (field === "algorithm") return;
            if (field === "key_hex") return;
            if (field === "iv_hex") return;
            if (field === "plain_text") return;
            throw new Error("v contains unknown field: " + field);
        });

        log.println("v.algorithm must be string");
        if (typeof v.algorithm !== "string") {
            throw new Error("v.algorithm is not string");
        }

        if (
            new Set([
                "aes-128-cbc",
                "aes-128-cbc-hmac-sha1",
                "aes-128-cbc-hmac-sha256",
                "aes-128-ccm",
                "aes-128-cfb",
                "aes-128-cfb1",
                "aes-128-cfb8",
                "aes-128-ctr",
                "aes-128-ecb",
                "aes-128-gcm",
                "aes-128-ocb",
                "aes-128-ofb",
                "aes-128-xts",
                "aes-192-cbc",
                "aes-192-ccm",
                "aes-192-cfb",
                "aes-192-cfb1",
                "aes-192-cfb8",
                "aes-192-ctr",
                "aes-192-ecb",
                "aes-192-gcm",
                "aes-192-ocb",
                "aes-192-ofb",
                "aes-256-cbc",
                "aes-256-cbc-hmac-sha1",
                "aes-256-cbc-hmac-sha256",
                "aes-256-ccm",
                "aes-256-cfb",
                "aes-256-cfb1",
                "aes-256-cfb8",
                "aes-256-ctr",
                "aes-256-ecb",
                "aes-256-gcm",
                "aes-256-ocb",
                "aes-256-ofb",
                "aes-256-xts",
                "aes128",
                "aes128-wrap",
                "aes192",
                "aes192-wrap",
                "aes256",
                "aes256-wrap",
                "aria-128-cbc",
                "aria-128-ccm",
                "aria-128-cfb",
                "aria-128-cfb1",
                "aria-128-cfb8",
                "aria-128-ctr",
                "aria-128-ecb",
                "aria-128-gcm",
                "aria-128-ofb",
                "aria-192-cbc",
                "aria-192-ccm",
                "aria-192-cfb",
                "aria-192-cfb1",
                "aria-192-cfb8",
                "aria-192-ctr",
                "aria-192-ecb",
                "aria-192-gcm",
                "aria-192-ofb",
                "aria-256-cbc",
                "aria-256-ccm",
                "aria-256-cfb",
                "aria-256-cfb1",
                "aria-256-cfb8",
                "aria-256-ctr",
                "aria-256-ecb",
                "aria-256-gcm",
                "aria-256-ofb",
                "aria128",
                "aria192",
                "aria256",
                "camellia-128-cbc",
                "camellia-128-cfb",
                "camellia-128-cfb1",
                "camellia-128-cfb8",
                "camellia-128-ctr",
                "camellia-128-ecb",
                "camellia-128-ofb",
                "camellia-192-cbc",
                "camellia-192-cfb",
                "camellia-192-cfb1",
                "camellia-192-cfb8",
                "camellia-192-ctr",
                "camellia-192-ecb",
                "camellia-192-ofb",
                "camellia-256-cbc",
                "camellia-256-cfb",
                "camellia-256-cfb1",
                "camellia-256-cfb8",
                "camellia-256-ctr",
                "camellia-256-ecb",
                "camellia-256-ofb",
                "camellia128",
                "camellia192",
                "camellia256",
                "chacha20",
                "chacha20-poly1305",
                "des-ede",
                "des-ede-cbc",
                "des-ede-cfb",
                "des-ede-ecb",
                "des-ede-ofb",
                "des-ede3",
                "des-ede3-cbc",
                "des-ede3-cfb",
                "des-ede3-cfb1",
                "des-ede3-cfb8",
                "des-ede3-ecb",
                "des-ede3-ofb",
                "des3",
                "des3-wrap",
                "id-aes128-CCM",
                "id-aes128-GCM",
                "id-aes128-wrap",
                "id-aes128-wrap-pad",
                "id-aes192-CCM",
                "id-aes192-GCM",
                "id-aes192-wrap",
                "id-aes192-wrap-pad",
                "id-aes256-CCM",
                "id-aes256-GCM",
                "id-aes256-wrap",
                "id-aes256-wrap-pad",
                "id-smime-alg-CMS3DESwrap",
                "sm4",
                "sm4-cbc",
                "sm4-cfb",
                "sm4-ctr",
                "sm4-ecb",
                "sm4-ofb"
            ]).has(v.algorithm) === false
        ) {
            throw new Error("v.algorithm is not a valid string enum value");
        }

        log.println("v.key_hex must be string");
        if (typeof v.key_hex !== "string") {
            throw new Error("v.key_hex is not string");
        }

        log.println("v.iv_hex must be string");
        if (typeof v.iv_hex !== "string") {
            throw new Error("v.iv_hex is not string");
        }

        log.println("v.plain_text must be string");
        if (typeof v.plain_text !== "string") {
            throw new Error("v.plain_text is not string");
        }
    } catch (err) {
        log.error(err);
        return cb.fail(err);
    }
    // nothing wrong
    log.ok();
    return cb.ok();
}

// JSON stringify value before copy to handle some specific problem
// eg. Date Object probelm
export function copy_output_ok(v: any): OutputOk {
    if (v !== undefined) {
        const v_cloned = JSON.parse(JSON.stringify(v));
        return _copy_output_ok(v_cloned);
    } else {
        return _copy_output_ok(v);
    }
}

export function _copy_output_ok(v: any): OutputOk {
    if (typeof v === "object" && v !== null) {
        const obj = {
            ciphered_text_hex: copy_ciphered_text_hex(v.ciphered_text_hex)
        };
        return obj;
    } else {
        return { ciphered_text_hex: "" };
    }

    function copy_ciphered_text_hex(v: any): string {
        return typeof v === "string" ? v : "";
    }
}

// backward compatible purpose
export type Output = OutputOk;
export const copy_output = copy_output_ok;
