// auto generated by dev/system

import { Logger } from "../../../myutils/logger.js";
import { Input, Output, Callback } from "./type.js";
import * as store from "../_/node/index.js";
import { make_sort_fun } from "./sort/index.js";

export async function core<R>(plog: Logger, input: Input, cb: Callback<R>): Promise<R> {
    const log = plog.sub("x-brokerchain-store.node-ls");
    log.variable("input", input);

    // online system can be very slow when not disabled
    log.warn("log disabled for performance reason, if you want to check the data here, you can edit the code here to enable");

    return await store.ls(
        log,
        {
            sort: make_sort_fun(
                log,
                {
                    sort_request: input.sort
                },
                {
                    none: () => {
                        return undefined;
                    },
                    ok: (sort_fun) => {
                        return sort_fun;
                    },
                    fail: (err) => {
                        throw err;
                    }
                }
            )
        },
        {
            empty: () => {
                return cb.empty({ list: [], total_count: 0 });
            },
            ok: (list, engine) => {
                const paged_list = apply_pagination(log, input, list);
                return cb.ok({ list: paged_list.map((item) => store.copy_public(item)), total_count: list.length });
            },
            fail: (err) => {
                return cb.fail(err);
            }
        }
    );
}

// this function never throws any exections
// if the input value is out of range, it just returns an empty list
function apply_pagination(plog: Logger, input: Input, list: store.Node[]): store.Node[] {
    const log = plog.sub("apply_pagination");
    const page = input.page;
    if (page !== undefined) {
        const begin = page.offset;
        const end = page.offset + page.limit;
        return list.slice(begin, end);
    } else {
        return list;
    }
}
