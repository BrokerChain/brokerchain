// auto generated by dev/system

import { Logger } from "../../../myutils/logger.js";
import { Input, Output, Callback } from "./type.js";
import * as store from "../_/peer/index.js";
import { make_sort_fun } from "./sort/index.js";

export async function core<R>(log: Logger, input: Input & { global_filter_fun?: (item: store.Peer) => boolean }, cb: Callback<R>): Promise<R> {
    return await store.ls(
        log,
        {
            filter: input.global_filter_fun,
            sort: make_sort_fun(
                log,
                {
                    sort_request: input.sort
                },
                {
                    none: () => {
                        return undefined;
                    },
                    ok: (sort_fun) => {
                        return sort_fun;
                    },
                    fail: (err) => {
                        throw err;
                    }
                }
            )
        },
        {
            empty: () => {
                return cb.empty({ list: [], total_count: 0 });
            },
            ok: (list, engine) => {
                const paged_list = apply_pagination(log, input, list);
                if (paged_list.length === 0) {
                    return cb.empty({ list: [], total_count: list.length });
                } else {
                    return cb.ok({ list: paged_list, total_count: list.length });
                }
            },
            fail: (err) => {
                return cb.fail(err);
            }
        }
    );
}

// this function never throws any exections
// if the input value is out of range, it just returns an empty list
function apply_pagination(plog: Logger, input: Input, list: store.Peer[]): store.Peer[] {
    const log = plog.sub("apply_pagination");
    const page = input.page;
    if (page !== undefined) {
        const begin = page.offset;
        const end = page.offset + page.limit;
        return list.slice(begin, end);
    } else {
        return list;
    }
}
