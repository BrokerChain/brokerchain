// auto generated by dev/system

import { Logger } from "../../../myutils/logger.js";
import { prompts } from "../../../myutils/index.js";
import { read_json_file } from "../../../myutils/node/file/index.js";
import { Input, Output, check_input, OutputEmpty, OutputOk } from "./type.js";
import { core } from "./core.js";
import { rpc_node_ls_raw } from "./rpc/client.js";
import yargs from "yargs";

const log = new Logger("cli");
run();

async function run() {
    try {
        const { input, server } = await make_input(log, {
            ok: async (input: Input, server) => {
                return { input, server };
            },
            fail: async (err) => {
                throw err;
            }
        });

        if (server) {
            await rpc_node_ls_raw(
                log,
                {
                    server,
                    input
                },
                {
                    empty: (output) => {
                        log.variable("output", output);
                        console.log("ðŸ˜„ empty");
                    },

                    ok: (output) => {
                        log.variable("output", output);
                        console.log("ðŸ˜„ ok");
                    },

                    fail: (err) => {
                        throw err;
                    }
                }
            );
        } else {
            await core(log, input, {
                empty: (output: OutputEmpty) => {
                    log.variable("output", output);
                    console.log("ðŸ˜„ empty");
                },

                ok: (output: OutputOk) => {
                    log.variable("output", output);
                    console.log("ðŸ˜„ ok");
                },

                fail: (err) => {
                    throw err;
                }
            });
        }
    } catch (err) {
        log.print_unknown_error(err);
        console.log("ðŸ˜¢ fail.");
    }
}

async function make_input<R>(
    plog: Logger,
    cb: {
        ok: (input: Input, rpc_server: string) => R;
        fail: (err: Error) => R;
    }
): Promise<R> {
    const log = plog.sub("make_input");

    const args = await yargs(process.argv.slice(2))
        .option("input", {
            type: "string",
            description: "Specify the JSON input directly as a command line argument."
        })
        .option("input-file", {
            type: "string",
            description: "Provide the name of a JSON file from which to read the input."
        })
        .option("server", {
            type: "string",
            description: "Provide the URL of a remote server to send the request to."
        })
        .parse();

    const input = args.input || process.env["x_input"];
    log.variable("input", input);

    const input_file = args.inputFile || process.env["x_input_file"];
    log.variable("input_file", input_file);

    const server = args.server || process.env["x_server"];
    log.variable("x_server", server);

    if (input && input_file) {
        return cb.fail(log.new_error("Conflicting arguments provided. You can use either --input or --input-file, but not both at the same time."));
    }

    if (input) {
        return make_input_from_args(
            log,
            { json_text: input },
            {
                ok: (input) => {
                    return cb.ok(input, server);
                },
                fail: (err) => {
                    return cb.fail(err);
                }
            }
        );
    } else if (input_file) {
        return make_input_from_file(
            log,
            { filename: input_file },
            {
                ok: (input) => {
                    return cb.ok(input, server);
                },
                fail: (err) => {
                    return cb.fail(err);
                }
            }
        );
    } else {
        return make_input_from_prompts(log, {
            ok: (input) => {
                return cb.ok(input, server);
            },
            fail: (err) => {
                return cb.fail(err);
            }
        });
    }
}

async function make_input_from_args<R>(
    plog: Logger,
    opts: { json_text: string },
    cb: {
        ok: (input: Input) => R;
        fail: (err: Error) => R;
    }
): Promise<R> {
    const log = plog.sub("make_input_from_args");
    try {
        const input = JSON.parse(opts.json_text);
        log.variable("input", input);

        return check_input(log, input, {
            ok: () => {
                return cb.ok(input);
            },
            fail: (err) => {
                return cb.fail(err);
            }
        });
    } catch (err) {
        log.print_unknown_error(err);
        return cb.fail(err);
    }
}

async function make_input_from_file<R>(
    plog: Logger,
    opts: { filename: string },
    cb: {
        ok: (input: Input) => R;
        fail: (err: Error) => R;
    }
): Promise<R> {
    const log = plog.sub("make_input_from_file");
    return read_json_file(log, opts.filename, {
        ok: (input) => {
            return check_input(log, input, {
                ok: () => {
                    return cb.ok(input);
                },
                fail: (err) => {
                    return cb.fail(err);
                }
            });
        },
        fail: (err) => {
            return cb.fail(err);
        }
    });
}

async function make_input_from_prompts<R>(
    plog: Logger,
    cb: {
        ok: (v: {
            sort?: {
                field_list: {
                    id?: { order: "ascending" | "descending" };
                    fake?: { order: "ascending" | "descending" };
                    create_time?: { order: "ascending" | "descending" };
                    update_time?: { order: "ascending" | "descending" };
                    address?: { order: "ascending" | "descending" };
                    port?: { order: "ascending" | "descending" };
                }[];
            };
            page?: { offset: number; limit: number };
        }) => R;
        fail: (err: Error) => R;
    }
): Promise<R> {
    const log = plog.sub("make_input_from_prompts");
    try {
        var v: {
            sort?: {
                field_list: {
                    id?: { order: "ascending" | "descending" };
                    fake?: { order: "ascending" | "descending" };
                    create_time?: { order: "ascending" | "descending" };
                    update_time?: { order: "ascending" | "descending" };
                    address?: { order: "ascending" | "descending" };
                    port?: { order: "ascending" | "descending" };
                }[];
            };
            page?: { offset: number; limit: number };
        } = {
            sort: await skip_or_input("sort", () =>
                input_sort(log.sub("sort"), {
                    ok: (v) => v,
                    fail: (err) => {
                        throw err;
                    }
                })
            ),
            page: await skip_or_input("page", () =>
                input_page(log.sub("page"), {
                    ok: (v) => v,
                    fail: (err) => {
                        throw err;
                    }
                })
            )
        };
    } catch (err) {
        log.error(err);
        return cb.fail(err);
    }

    return cb.ok(v);

    async function input_sort<R>(
        plog: Logger,
        cb: {
            ok: (v: {
                field_list: {
                    id?: { order: "ascending" | "descending" };
                    fake?: { order: "ascending" | "descending" };
                    create_time?: { order: "ascending" | "descending" };
                    update_time?: { order: "ascending" | "descending" };
                    address?: { order: "ascending" | "descending" };
                    port?: { order: "ascending" | "descending" };
                }[];
            }) => R;
            fail: (err: Error) => R;
        }
    ): Promise<R> {
        const log = plog.sub("input_sort");
        try {
            var v: {
                field_list: {
                    id?: { order: "ascending" | "descending" };
                    fake?: { order: "ascending" | "descending" };
                    create_time?: { order: "ascending" | "descending" };
                    update_time?: { order: "ascending" | "descending" };
                    address?: { order: "ascending" | "descending" };
                    port?: { order: "ascending" | "descending" };
                }[];
            } = {
                field_list: await input_field_list(log.sub("field_list"), {
                    ok: (v) => v,
                    fail: (err) => {
                        throw err;
                    }
                })
            };
        } catch (err) {
            log.error(err);
            return cb.fail(err);
        }

        return cb.ok(v);

        async function input_field_list<R>(
            plog: Logger,
            cb: {
                ok: (
                    v: {
                        id?: { order: "ascending" | "descending" };
                        fake?: { order: "ascending" | "descending" };
                        create_time?: { order: "ascending" | "descending" };
                        update_time?: { order: "ascending" | "descending" };
                        address?: { order: "ascending" | "descending" };
                        port?: { order: "ascending" | "descending" };
                    }[]
                ) => R;
                fail: (err: Error) => R;
            }
        ): Promise<R> {
            const log = plog.sub("input_field_list");
            const length = await prompts.input_number("(array.length) field_list");
            const list: {
                id?: { order: "ascending" | "descending" };
                fake?: { order: "ascending" | "descending" };
                create_time?: { order: "ascending" | "descending" };
                update_time?: { order: "ascending" | "descending" };
                address?: { order: "ascending" | "descending" };
                port?: { order: "ascending" | "descending" };
            }[] = [];
            for (let i = 0; i < length; ++i) {
                const err = await input_item(log, {
                    ok: (item) => {
                        list.push(item);
                        return null;
                    },
                    fail: (err) => {
                        return err;
                    }
                });

                if (err) {
                    return cb.fail(err);
                }
            }

            return cb.ok(list);

            async function input_item<R>(
                plog: Logger,
                cb: {
                    ok: (v: {
                        id?: { order: "ascending" | "descending" };
                        fake?: { order: "ascending" | "descending" };
                        create_time?: { order: "ascending" | "descending" };
                        update_time?: { order: "ascending" | "descending" };
                        address?: { order: "ascending" | "descending" };
                        port?: { order: "ascending" | "descending" };
                    }) => R;
                    fail: (err: Error) => R;
                }
            ): Promise<R> {
                const log = plog.sub("input_item");
                try {
                    var v: {
                        id?: { order: "ascending" | "descending" };
                        fake?: { order: "ascending" | "descending" };
                        create_time?: { order: "ascending" | "descending" };
                        update_time?: { order: "ascending" | "descending" };
                        address?: { order: "ascending" | "descending" };
                        port?: { order: "ascending" | "descending" };
                    } = {
                        id: await skip_or_input("id", () =>
                            input_id(log.sub("id"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        ),
                        fake: await skip_or_input("fake", () =>
                            input_fake(log.sub("fake"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        ),
                        create_time: await skip_or_input("create_time", () =>
                            input_create_time(log.sub("create_time"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        ),
                        update_time: await skip_or_input("update_time", () =>
                            input_update_time(log.sub("update_time"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        ),
                        address: await skip_or_input("address", () =>
                            input_address(log.sub("address"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        ),
                        port: await skip_or_input("port", () =>
                            input_port(log.sub("port"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        )
                    };
                } catch (err) {
                    log.error(err);
                    return cb.fail(err);
                }

                return cb.ok(v);

                async function input_id<R>(plog: Logger, cb: { ok: (v: { order: "ascending" | "descending" }) => R; fail: (err: Error) => R }): Promise<R> {
                    const log = plog.sub("input_id");
                    try {
                        var v: { order: "ascending" | "descending" } = {
                            order: await input_order(log.sub("order"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        };
                    } catch (err) {
                        log.error(err);
                        return cb.fail(err);
                    }

                    return cb.ok(v);

                    async function input_order<R>(plog: Logger, cb: { ok: (v: "ascending" | "descending") => R; fail: (err: Error) => R }): Promise<R> {
                        const log = plog.sub("input_order");
                        // FIXME implement all string constrains here
                        const v: "ascending" | "descending" = await prompts.input_string_enum("order", ["ascending", "descending"]);
                        return cb.ok(v);
                    }
                }

                async function input_fake<R>(plog: Logger, cb: { ok: (v: { order: "ascending" | "descending" }) => R; fail: (err: Error) => R }): Promise<R> {
                    const log = plog.sub("input_fake");
                    try {
                        var v: { order: "ascending" | "descending" } = {
                            order: await input_order(log.sub("order"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        };
                    } catch (err) {
                        log.error(err);
                        return cb.fail(err);
                    }

                    return cb.ok(v);

                    async function input_order<R>(plog: Logger, cb: { ok: (v: "ascending" | "descending") => R; fail: (err: Error) => R }): Promise<R> {
                        const log = plog.sub("input_order");
                        // FIXME implement all string constrains here
                        const v: "ascending" | "descending" = await prompts.input_string_enum("order", ["ascending", "descending"]);
                        return cb.ok(v);
                    }
                }

                async function input_create_time<R>(
                    plog: Logger,
                    cb: { ok: (v: { order: "ascending" | "descending" }) => R; fail: (err: Error) => R }
                ): Promise<R> {
                    const log = plog.sub("input_create_time");
                    try {
                        var v: { order: "ascending" | "descending" } = {
                            order: await input_order(log.sub("order"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        };
                    } catch (err) {
                        log.error(err);
                        return cb.fail(err);
                    }

                    return cb.ok(v);

                    async function input_order<R>(plog: Logger, cb: { ok: (v: "ascending" | "descending") => R; fail: (err: Error) => R }): Promise<R> {
                        const log = plog.sub("input_order");
                        // FIXME implement all string constrains here
                        const v: "ascending" | "descending" = await prompts.input_string_enum("order", ["ascending", "descending"]);
                        return cb.ok(v);
                    }
                }

                async function input_update_time<R>(
                    plog: Logger,
                    cb: { ok: (v: { order: "ascending" | "descending" }) => R; fail: (err: Error) => R }
                ): Promise<R> {
                    const log = plog.sub("input_update_time");
                    try {
                        var v: { order: "ascending" | "descending" } = {
                            order: await input_order(log.sub("order"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        };
                    } catch (err) {
                        log.error(err);
                        return cb.fail(err);
                    }

                    return cb.ok(v);

                    async function input_order<R>(plog: Logger, cb: { ok: (v: "ascending" | "descending") => R; fail: (err: Error) => R }): Promise<R> {
                        const log = plog.sub("input_order");
                        // FIXME implement all string constrains here
                        const v: "ascending" | "descending" = await prompts.input_string_enum("order", ["ascending", "descending"]);
                        return cb.ok(v);
                    }
                }

                async function input_address<R>(
                    plog: Logger,
                    cb: { ok: (v: { order: "ascending" | "descending" }) => R; fail: (err: Error) => R }
                ): Promise<R> {
                    const log = plog.sub("input_address");
                    try {
                        var v: { order: "ascending" | "descending" } = {
                            order: await input_order(log.sub("order"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        };
                    } catch (err) {
                        log.error(err);
                        return cb.fail(err);
                    }

                    return cb.ok(v);

                    async function input_order<R>(plog: Logger, cb: { ok: (v: "ascending" | "descending") => R; fail: (err: Error) => R }): Promise<R> {
                        const log = plog.sub("input_order");
                        // FIXME implement all string constrains here
                        const v: "ascending" | "descending" = await prompts.input_string_enum("order", ["ascending", "descending"]);
                        return cb.ok(v);
                    }
                }

                async function input_port<R>(plog: Logger, cb: { ok: (v: { order: "ascending" | "descending" }) => R; fail: (err: Error) => R }): Promise<R> {
                    const log = plog.sub("input_port");
                    try {
                        var v: { order: "ascending" | "descending" } = {
                            order: await input_order(log.sub("order"), {
                                ok: (v) => v,
                                fail: (err) => {
                                    throw err;
                                }
                            })
                        };
                    } catch (err) {
                        log.error(err);
                        return cb.fail(err);
                    }

                    return cb.ok(v);

                    async function input_order<R>(plog: Logger, cb: { ok: (v: "ascending" | "descending") => R; fail: (err: Error) => R }): Promise<R> {
                        const log = plog.sub("input_order");
                        // FIXME implement all string constrains here
                        const v: "ascending" | "descending" = await prompts.input_string_enum("order", ["ascending", "descending"]);
                        return cb.ok(v);
                    }
                }

                async function skip_or_input<R>(field: string, input_cb: () => Promise<R>): Promise<R | undefined> {
                    const v = await prompts.input_string_enum(field, ["skip", "input"]);
                    if (v === "input") {
                        return input_cb();
                    } else {
                        return undefined;
                    }
                }
            }
        }
    }

    async function input_page<R>(plog: Logger, cb: { ok: (v: { offset: number; limit: number }) => R; fail: (err: Error) => R }): Promise<R> {
        const log = plog.sub("input_page");
        try {
            var v: { offset: number; limit: number } = {
                offset: await input_offset(log.sub("offset"), {
                    ok: (v) => v,
                    fail: (err) => {
                        throw err;
                    }
                }),
                limit: await input_limit(log.sub("limit"), {
                    ok: (v) => v,
                    fail: (err) => {
                        throw err;
                    }
                })
            };
        } catch (err) {
            log.error(err);
            return cb.fail(err);
        }

        return cb.ok(v);

        async function input_offset<R>(plog: Logger, cb: { ok: (v: number) => R; fail: (err: Error) => R }): Promise<R> {
            const log = plog.sub("input_offset");
            // FIXME implement all number constrains here
            const v = await prompts.input_number("offset");
            return cb.ok(v);
        }

        async function input_limit<R>(plog: Logger, cb: { ok: (v: number) => R; fail: (err: Error) => R }): Promise<R> {
            const log = plog.sub("input_limit");
            // FIXME implement all number constrains here
            const v = await prompts.input_number("limit");
            return cb.ok(v);
        }
    }

    async function skip_or_input<R>(field: string, input_cb: () => Promise<R>): Promise<R | undefined> {
        const v = await prompts.input_string_enum(field, ["skip", "input"]);
        if (v === "input") {
            return input_cb();
        } else {
            return undefined;
        }
    }
}
