// auto generated by dev/system

import * as React from "react";
import { render } from "./render.js";
import { PoolProps, PoolState, init_state } from "./type.js";
import { did_mount } from "./lifecycle/did_mount.js";
import { will_unmount } from "./lifecycle/will_unmount.js";
import { did_update } from "./lifecycle/did_update.js";
import { Extend } from "./extend.js";

export class Pool extends React.Component<PoolProps, PoolState> {
    extend: Extend;

    constructor(props: PoolProps) {
        super(props);
        this.state = init_state();
        this.extend = new Extend(this);
    }

    componentDidMount() {
        did_mount(this);
    }

    componentWillUnmount() {
        will_unmount(this);
    }

    componentDidUpdate(prevProps: Readonly<PoolProps>, prevState: Readonly<PoolState>, snapshot?: any): void {
        did_update(this, { props: prevProps, state: prevState });
    }

    shouldComponentUpdate(nextProps: Readonly<PoolProps>, nextState: Readonly<PoolState>, nextContext: any): boolean {
        // Detect whether props have changed.
        // However, the 'vio' prop is treated differently:
        // - The 'vio' object can change, which is fine, it will not trigger a re-render.

        const self = this;

        if (is_vio_value_changed()) {
            debug_log("vio value changed");
            return true;
        }

        if (is_props_changed()) {
            debug_log("props changed");
            return true;
        }

        if (is_state_changed()) {
            debug_log("state changed");
            return true;
        }

        debug_log("nothing changed");
        return false;

        function is_vio_value_changed() {
            const current = self.props.vio;
            const next = nextProps.vio;
            // debug_log("current.value", JSON.stringify(current.value.toJSON(), null, 4));
            // debug_log("next.value", JSON.stringify(next.value.toJSON(), null, 4));
            // Check the value field; ignore the io field (different io objects are acceptable).
            if (current.value.equals(next.value)) {
                return false;
            } else {
                return true;
            }
        }

        function is_props_changed() {
            const currentPropNameList = Object.keys(self.props).filter((name) => name !== "vio");
            const nextPropNameList = Object.keys(nextProps).filter((name) => name !== "vio");
            if (currentPropNameList.length !== nextPropNameList.length) {
                return true;
            } else {
                for (const name of currentPropNameList) {
                    if ((self.props as any)[name] !== (nextProps as any)[name]) {
                        return true;
                    }
                }
                return false;
            }
        }

        function is_state_changed() {
            return self.state !== nextState;
        }

        function debug_log(...args: any[]) {
            // console.log("NodePool.shouldComponentUpdate()", ...args);
        }
    }

    render() {
        // console.log("NodePool.render()");
        return render(this);
    }
}
